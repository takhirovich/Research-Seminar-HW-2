Swift | Reaproveitando Views utilizando State Design Pattern Hoje quero compartilhar com vocês um cenário que é extremamente comum em diversas aplicações, que á primeira vista parece simples, mas que permite aplicar diversos conceitos importantes de programação, em especial relacionados a design patterns e princípios SOLID. Vamos começar analisando o cenário em questão através da imagem abaixo:  Basicamente temos aqui um cadastro em multi-step, onde capturamos uma informação do usuário por vez. Logo de início conseguimos notar que embora as informações captadas, bem como os textos, sejam diferentes, o layout de todas as telas é praticamente o mesmo. Partindo disso, vamos listar os pontos de diferença entre cada uma das telas: Informações textuais tais como: título, placeholder do textField e resumo das informações do usuário; Máscara de textField bem como possíveis regras de validação da entrada do usuário; Ação associada ao botão de continuar. Dado o contexto, vamos levantar o problema que desejamos solucionar: Como separar os diferentes comportamentos de cada tela de maneira efetiva e reaproveitando a camada de View (UIView e UIViewController)? Existem diversas boas maneiras de resolver esse problema, aqui nesse artigo vamos optar por utilizar o design pattern chamado State. A ideia será transformar cada tipo de informação que desejamos recuperar em um estado para nossa camada de View. Nesse artigo essa camada será representada por uma classe chamada FormViewController. Vamos começar criando um protocolo que irá representar as capacidades que cada estado precisa ter, que no caso são as que listamos mais acima nesse artigo:  Em seguida vamos criar as classes concretas, que irão implementar o protocolo FormState que acabamos de criar e que representarão cada um dos estados de input de informações:  Aqui vale ressaltar dois pontos extremamente importantes: 1. Adição de método init que recebe uma UIViewController Esse ponto é importante pois aqui estamos utilizando injeção de dependência para fornecer para nossas classes de estado uma referência de FormViewController que contém as dependências necessárias para realizarmos tanto as modificações textuais como as validações de textField e ações do botão continuar. 2. Não inclusão do método init ao protocolo FormState Aqui a ideia é evitar qualquer tipo de acoplamento ao nosso protocolo State, ele deve conter apenas abstrações dos comportamentos esperados para cada estado. Dando sequência ao código, por fim, nós iremos adicionar à nossa classe FormViewController, que é a classe que contém toda parte de layout reaproveitável, uma variável do tipo FormState e chamaremos os métodos desse protocolo nos locais apropriados:  Fazendo isso a classe FormViewController, que contém todo layout reaproveitável, passa a facilmente conseguir se adequar a diferentes estados por intermédio de um objeto FormState, além de permitir que novas telas possam ser adicionadas a esse fluxo de formulário, sendo necessário apenas criar novas classes que implementem o protocolo FormState, baseado no Open/Closed principle do SOLID. Protocolos são ferramentas extremamente poderosas que nos permitem criar diferentes níveis de abstração para aplicar e adequar os múltiplos design patterns que vemos na literatura, além de nos ajudar a compreender e aplicar os conceitos contidos dentro SOLID. Por hoje é isso pessoal! :)